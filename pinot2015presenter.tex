\documentclass{roadef}

\def\S{\mathcal{S}}

\begin{document}

\title{Présenter une~liste~de~dates de~manière~lisible: complexité~et~algorithmes}

% Le titre court
\def\shorttitle{Présenter une~liste~de~dates de~manière~lisible}

% Les auteurs et leur numéro d'affiliation
\author{Guillaume Pinot}

% Les affiliations (par ordre croissant des numéros d'affiliation) séparées par \and
\institute{
  Canal TP, 20 rue Hector Malot, 75012 Paris\\
  \email{guillaume.pinot@canaltp.fr}
}

% Création de la page de titre
\maketitle
\thispagestyle{empty}

% Les mots-clés
\keywords{complexité, algorithme, \emph{closest string problem}.}


\section{Introduction}

Canal TP

navitia et navitia.io

Dans navitia, nous fournissons les dates auxquelles circulent les
véhicules.  Or, une liste de dates est peu lisible par un humain. Nous
avons donc besoin de décrire sous forme condensée cette liste de dates.

\section{Le problème}

\subsection{Description du problème}

En entrée du problème, nous avons donc une liste de dates.  En sortie,
nous voulons écrire une phrase du genre \emph{du Lundi au Vendredi du
  27 avril au 31 mai 2015 sauf les 1, 8, 14 et 25 mai avec le 30 mai}.

Notre résultat à notre problème doit donc décrire notre liste de dates
avec:
\begin{itemize}
\item un rythme hebdomadaire (ex: du Lundi au Vendredi);
\item une période de validité (ex: du 27 avril au 31 mai);
\item une liste de date exclues (ex: sauf les 1, 8, 14 et 25 mai);
\item une liste de dates incluses (ex: avec le 6 mai).
\end{itemize}

Pour que notre description soit la plus simple possible, il faut
minimiser le nombre d'exceptions (les dates exclues et incluses).

Nous pouvons facilement transformer la liste de dates en succession de
rythmes hebdomadaires. Pour notre exemple, cela donnerait:
\begin{itemize}
\item Semaines du 27 avril et du 4 mai: Du Lundi au Jeudi;
\item Semaine du 11 mai: Du Lundi au Vendredi sauf Jeudi;
\item Semaine du 18 mai: Du Lundi au Vendredi;
\item Semaine du 25 mai: Du Mardi au Samedi.
\end{itemize}

Pour un rythme hebdomadaire donné, il est facile de généré notre
résultat.  Le problème est donc de trouver le rythme hebdomadaire
journalier tel que le nombre d'exceptions soit minimal.

\subsection{Modélisation mathématiques}

Nous pouvons modéliser notre rythme hebdomadaire grâce à une chaîne de
7~bits: un caractère par jour de la semaine, 0 pour un jour inactif, 1
pour un jour actif. Pour le rythme hebdomadaire «~du Lundi au
Vendredi~» nous avons donc la chaîne «~1111100~».

Les données du problèmes peuvent alors être modélisé comme une liste
de chaînes binaires de longueur 7 que l'on appellera
$\S$. Pour notre exemple, cela donne:
\begin{displaymath}
  \S = 1111000, 1111000, 1110100, 1111100, 0111110
\end{displaymath}

Si nous voulons décrire un rythme hebdomadaire $s_1$ en fonction d'un
autre $s_2$, le nombre d'exception est le nombre de substitutions de
caractère nécessaire pour aller de $s_1$ à $s_2$. Cette distance est
appelé la distance de Hamming \cite{hamming1950error}. On la notera
$d(s_1, s_2)$.

Pour résoudre notre problème, nous devons donc trouver la chaîne $s$
qui minimise la somme des distances avec $\S$. Ce qui nous donne la
formalisation suivante:

Soit $\S = s_1, s_2, \ldots, s_n$, $n$ chaînes binaire de
longueur 7. Soit
\begin{math}
  d_s = \sum_{s_i\in\S} d(s, s_i)
\end{math}.
Le meilleur rythme hebdomadaire est représenté par la chaîne $s$
minimisant $d_s$.

\section{Comparaison avec l'existant et complexité}

Le \emph{closest string problem} est un problème très proche du notre.
Il se définit ainsi: soit $\S = s_1, s_2, \ldots, s_n$, $n$ chaînes
sur l'alphabet $\Sigma$ de longueur $m$.  Soit $d_s = \max_{s_i\in\S}
d(s, s_i)$. Le \emph{closest string problem} a pour solution la
chaîne~$s$ de longueur $m$ minimisant $d_s$.

Ce problème est NP-difficile \cite{lanctot2003distinguishing} et sa
complexité paramétrique est
\begin{math}
  O(nm + nd\cdot(16|\Sigma|)^{d_s})
\end{math}
\cite{ma2008more}.

Notre problème est donc le \emph{closest string problem} avec $\Sigma
= \{0, 1\}, m = 7$ et une fonction objectif différente (nous
minimisons une somme au lieu de minimiser un maximum). La complexité
paramétrique du \emph{closest string problem} n'étant pas exponentiel
sur $n$, nous pouvons espérer trouver un algorithme polynomial pour
résoudre notre problème (avec une constante potentiellement élevée
fonction de $|\Sigma|^m = 2^7 = 128$).

\section{Algorithme}

Pour résoudre notre problème, nous proposons d'énumérer toutes les
chaînes candidates, et d'en évaluer son coût. Nous gardons finalement
la chaîne minimisant le coût. Nous avons $|\Sigma|^m = 2^7 = 128$
chaînes possibles. Évaluer une solution a pour complexité $O(mn) =
O(7n) = O(n)$. Ainsi, la complexité globale de notre algorithme est
$O(mn\cdot|\Sigma|^m) = O(7n\cdot128) = O(n)$. En pratique, le temps
de résolution est négligeable.\footnote{Notre implémentation utilise
  différentes optimisations et précalculs que nous ne pouvons
  expliquer dans cet article pour des raisons de place. La complexité
  théorique est la même.}

\section{Conclusions et perspectives}

conclusions

perspectives: Plusieurs patterns, Gestion des semaines partielles aux
bords.

\bibliographystyle{plain}
\bibliography{pinot2015presenter}

\end{document}
